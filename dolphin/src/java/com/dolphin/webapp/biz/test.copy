package com.dolphin.webapp.biz;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

import org.apache.commons.lang.StringUtils;

import com.dolphin.common.exception.GenericException;
import com.dolphin.common.log.DolpiLogger;
import com.dolphin.webapp.cache.CacheMgr;
import com.dolphin.webapp.dao.AccessDao;
import com.dolphin.webapp.vo.Access;
import com.dolphin.webapp.vo.AccessMain;
import com.dolphin.webapp.vo.AccessResponse;
import com.dolphin.webapp.vo.AccessSearchVO;
import com.dolphin.webapp.vo.AccessSum;
import com.dolphin.webapp.vo.AdsDetailContent;
import com.dolphin.webapp.vo.App;
import com.dolphin.webapp.vo.PhoneCharge;
import com.dolphin.webapp.vo.PhoneNumType;
import com.dolphin.webapp.vo.PhoneProduct;
import com.dolphin.webapp.vo.Rule;
import com.dolphin.webapp.vo.RuleAccessDailyCharge;
import com.dolphin.webapp.vo.RuleAccessMonthlyCharge;
import com.dolphin.webapp.vo.SyncObject;
import com.dolphin.webapp.vo.SystemConfig;

public class AccessMgrImpl implements AccessMgr {
	
	public final static String __RESP_PREFIX = "ADS_RESPONSE_";	
	
	public final static String _FIRST_HIT_ = "FIRST_HIT_";	

	private static SyncObject correctSync = new SyncObject("correct");

	private AccessDao accessDao;
	private RuleMgr ruleMgr;
	private	PublicMgr pubMgr;
	private ScriptMgr scriptMgr;
	private AppMgr appMgr;
	private AdsMgr adsMgr;
	private CacheMgr cacheMgr;

	
	DolpiLogger logger = new DolpiLogger(AccessMgrImpl.class.getName());
	

	public void setAccessDao(AccessDao accessDao) {
		this.accessDao = accessDao;
	}
	public void setRuleMgr(RuleMgr ruleMgr) {
		this.ruleMgr = ruleMgr;
	}
	public void setScriptMgr(ScriptMgr scriptMgr) {
		this.scriptMgr = scriptMgr;
	}
	public void setAppMgr(AppMgr appMgr) {
		this.appMgr = appMgr;
	}
	public void setPubMgr(PublicMgr pubMgr) {
		this.pubMgr = pubMgr;
	}
	public void setAdsMgr(AdsMgr adsMgr) {
		this.adsMgr = adsMgr;
	}
	public void setCacheMgr(CacheMgr cacheMgr) {
		this.cacheMgr = cacheMgr;
	}	
	
	
	public int insertAccess(Access access) throws GenericException {
		return accessDao.create(access);
	}
	
	private boolean isCMCC(String imsi) {
		return imsi.startsWith("46000") || imsi.startsWith("46002") || imsi.startsWith("46007") 
	           || imsi.startsWith("946000") || imsi.startsWith("946002") || imsi.startsWith("946007") ;
	}
	
	private static String _SERVICE_PROVIDER_CHINA_MOBILE = "chinamobile";
	private static String _SERVICE_PROVIDER_CHINA_UNICOM = "chinaunicom";
	private static String _SERVICE_PROVIDER_CHINA_TELCOM = "chinatelcom";
	
	private static String _APP_TYPE_ADS = "1";
	private static String _APP_TYPE_CALC_PREMIUM = "2";
	
	
	private AccessResponse getInvalidInputResponse(Access access, SystemConfig sc) throws GenericException {
		int defaultInteval = sc.getDefaultIntevalDays() * 24 * 60;
		String info = "{IMSI="+access.getImsi() 
				+ ",ProducType="+access.getProductType()+ ",SMSC="+access.getSmsc() +"}";			
		access.setResponseScriptContent(info);
		access.setResponseStatus("INVALID_INPUT");
		access.setInterval(defaultInteval);
		accessDao.create(access);
		return  getDefaultAccessResponse(defaultInteval,"INVALID_INPUT");	
	}
	
	private void setDefaultValue(Access access) throws GenericException {
		//0.1 if productype is null , set setProductType to default
		if(StringUtils.isEmpty(access.getProductType())){
			access.setProductType("DEFAULT");
		}
		//0.2 if smsc is null, set province/city to default
		if(StringUtils.isEmpty(access.getSmsc())){
			access.setProvince("DEFAULT");
			access.setCity("DEFAULT");
		}
	}
	
	private AccessMain insertOrUpdateAccessMain(AccessMain accessMain, Access access, String serviceprovider)   throws GenericException {
		boolean fristAccess = accessMain==null || accessMain.getFirstAccessTime()==null;
		if(fristAccess){
			accessMain = new AccessMain();
			accessMain.setFirstAccessTime(access.getAccessTime());
			accessMain.setImsi(access.getImsi());
			accessMain.setPublishDate(access.getPublishDate());
			accessMain.setSmsc(access.getSmsc());
			accessMain.setProductType(access.getProductType());
			accessMain.setVersion(access.getVersion());
			accessMain.setServiceprovider(serviceprovider);
			String smsc = access.getSmsc();
			try {
				String prefix = getPhonePrefix(smsc);
				PhoneNumType phoneNumType = null;
				if(StringUtils.isNotBlank(prefix)){
					phoneNumType = pubMgr.getPhoneNumType(getPhonePrefix(smsc));
				}
				if(phoneNumType !=null){
					accessMain.setProvince(phoneNumType.getProvincecode());
					accessMain.setCity(phoneNumType.getCitycode());
				} else{
					accessMain.setProvince("DEFAULT");
					accessMain.setCity("DEFAULT");
//					logger.error("Cannot find mobile phone num prefix by " + smscPrefix  +", and SMSC is"+access.getSmsc());
				}
			} catch (Exception e) {
				accessMain.setProvince("DEFAULT");
				accessMain.setCity("DEFAULT");
				logger.error("Cannot find mobile phone num prefix for IMSI is"+access.getImsi()+" because of "+e.getMessage());
			}
			
			//Add protection, for multiple threads
			try {
				accessDao.insertAccessMain(accessMain);
			} catch (Exception e) {
				logger.error("Is not first access, go others flow:"+getExceptionStackTrace(e));
			}
			access.setProvince(accessMain.getProvince());
			access.setCity(accessMain.getCity());
			
			return accessMain;
		} else {
			boolean noCity = "DEFAULT".equalsIgnoreCase(accessMain.getCity()) || StringUtils.isEmpty(accessMain.getCity());
			boolean noSerivceProvider = StringUtils.isEmpty(accessMain.getServiceprovider());
			accessMain.setServiceprovider(serviceprovider);
			
			if(noCity || noSerivceProvider){
				String phoneNo = accessMain.getPhoneno();
				//Re-populate city
				if(StringUtils.isNotEmpty(phoneNo)){
					try {
						String prefix = getPhonePrefix(phoneNo);
						if(StringUtils.isNotBlank(prefix)){
							PhoneNumType phoneNumType = pubMgr.getPhoneNumType(getPhonePrefix(phoneNo));
							if(phoneNumType !=null){
								accessMain.setProvince(phoneNumType.getProvincecode());
								accessMain.setCity(phoneNumType.getCitycode());
							}								
						} else {
							logger.error("Cannot find mobile phone num prefix for phoneNo is"+ phoneNo);
						}
					} catch (Exception e) {
						logger.error("Cannot find mobile phone num prefix for phoneNo is"+ phoneNo +" because of "+e.getMessage());
					}
				
				}
				
				//Update Service Provider
				accessDao.updatePhone(accessMain);
			}
			
			access.setProvince(accessMain.getProvince());
			access.setCity(accessMain.getCity());
			long gapDays  =(access.getAccessTime().getTime()-accessMain.getFirstAccessTime().getTime())/(24*60*60*1000);
			access.setGapdays(gapDays);
			
			return accessMain;
		}		
		
	}
	
	class Block{
		private boolean isBlock = false;
		private String blockReason;
		public boolean isBlock() {
			return isBlock;
		}
		public void setBlock(boolean isBlock) {
			this.isBlock = isBlock;
		}
		public String getBlockReason() {
			return blockReason;
		}
		public void setBlockReason(String blockReason) {
			this.blockReason = blockReason;
		}
	}
	
	private Block checkIsBlock(PhoneProduct product, AccessMain accessMain){
		Block block = new Block();
		boolean isBlock = "Block".equalsIgnoreCase(product.getStatus());
		//first check if product blocked
		if(!isBlock){
			//Check if imsi blocked
			isBlock = accessMain!=null && "Block".equalsIgnoreCase(accessMain.getStatus());
			if(isBlock){
				block.setBlock(true);
				block.setBlockReason("block");			
			}
		} else {
			block.setBlock(true);
			block.setBlockReason("productBlock");
		}
		return block;
	}
	
	

	/**
	 *  1st access need handle table 
	 *  	t_phone_product
	 *      t_phone
	 *      t_access_sum
	 *      t_access
	 *  
	 *  2nd access need handle table
	 *      t_access_sum
	 *      t_access
	 *      
	 */
	public AccessResponse newAccess(Access access) throws GenericException {
		AccessResponse response = initializeNewAccess(access);
		if(response!=null && ( response.getAppStream() ==null || response.getAppStream().length ==0) ){
			App app = appMgr.getAppByAppcode("DEFAULT_APP_"+access.getVersion());
			if(app!=null){
				byte []  is = appMgr.getAppStream(app.getAppID());
				response.setAppStream(is);	
			}
		}
		return response;
	}
	
	/**
	 *  1st access need handle table 
	 *  	t_phone_product
	 *      t_phone
	 *      t_access_sum
	 *      t_access
	 *  
	 *  2nd access need handle table
	 *      t_access_sum
	 *      t_access
	 *      
	 */
	private AccessResponse initializeNewAccess(Access access) throws GenericException {
		String curretnYearMonth = new SimpleDateFormat("yyyyMM").format(access.getAccessTime());
		String currdate = new SimpleDateFormat("yyyyMMdd").format(access.getAccessTime());
		access.setAccesstimeym(curretnYearMonth);
		access.setCurrdate(currdate);
		
		SystemConfig sc = pubMgr.getSystemConfig();
		
		//0: check input validity
		boolean isCMCC = isCMCC(access.getImsi());
		String serviceProvider = isCMCC ? _SERVICE_PROVIDER_CHINA_MOBILE : _SERVICE_PROVIDER_CHINA_UNICOM;
		if(StringUtils.isEmpty(access.getImsi())) {
			return  getInvalidInputResponse(access, sc);	
		}
		setDefaultValue(access); //0.1 set defualt value

		try {
			//1.0 check if need correct error because maybe last access error because of no ack 
			AccessResponse correctResp = handleCorrectErrorInsertAccess(access, sc);
			if(correctResp!=null){
				return correctResp;
			}
			
			//1.1 getPhoneProductAndInsert
			PhoneProduct product = pubMgr.getPhoneProductAndInsert(access.getProductType(), access.getVersion());
			
			//1.2: Check if this is the first access.
			//   if yes, need insert into another table
			//   if no,  get the first access record.
			AccessMain dbAccessMain = accessDao.loadPhoneAccessMainBySMSI(access.getImsi());

			//1.3  Prepare Access Data (province, city)
			AccessMain accessMain = insertOrUpdateAccessMain(dbAccessMain, access, serviceProvider);
			
			//1.4 Check Product code if blocked
			AccessResponse blockResp = handleBlockInsertAccess(product, accessMain, access, sc);
			if(blockResp!=null){
//				cacheMgr.addCacheEntry(__RESP_PREFIX + access.getImsi(), blockResp);
				return blockResp;
			}
				
			//1.5 Check if need execute system rule
			if(isCMCC && StringUtils.isEmpty(accessMain.getPhoneno())){
				AccessResponse systemResp = handleSystemRuleAccess(access, sc);
				if(systemResp!=null){
					cacheMgr.addCacheEntry(__RESP_PREFIX + access.getImsi(), systemResp);
					return systemResp;
				}
			}	
			
			//##############################PartII: search rule########################################################
			AccessSum accessSum = getImsiMonthlyCharge(access,  sc, curretnYearMonth);
			//2.0: execute special rule if has not executed.
			AccessResponse specialRuleResponse = handleSpecialRuleAndInsertAccess(access, sc, accessMain);
			if(specialRuleResponse!=null){
				return specialRuleResponse;
			}
			
			boolean  isOnlySearchAds = false;
			if(accessSum!=null && "Limited".equals(accessSum.getChargstatus())){
				isOnlySearchAds = true;
			}
			//2.1 ,Search Rule by city
			Rule rule = ruleMgr.searchRule(access.getProvince(), access.getCity(), access.getProductType(), access.getVersion(), serviceProvider, access.getGapdays(), isOnlySearchAds);
			if(rule==null){
				return handleNoRuleAndInsertAccess(access, sc, serviceProvider);
			}		
			App app = appMgr.getAppByAppID(rule.getAppID());


			//2.2 
			if(_APP_TYPE_ADS.endsWith(app.getApptype())){//handle ADS APP
				int gapMinsWithWorkingTime = calcGapMinsWithWokingTime4Ads(access.getAccessTime(), sc);			
				//Only no ads data and is not in working time range, do it.
				if(!adsMgr.isExistsAdsData() && gapMinsWithWorkingTime>0){
					return handleNonWorkingtimeInsertAccess(access, sc ,gapMinsWithWorkingTime);		
				}				
				return handleAdsApp(accessSum, access, rule, sc, curretnYearMonth);
			} else {
				return handleChargApp(accessSum, access, rule, sc, curretnYearMonth);
			}
		} catch (Exception e) {
			return handleExcepAndInsertAccess(e, access, sc);		
			
		}
	}
	
		
	private synchronized boolean isMaxLimitAds(AccessSum accessSum,Access access, SystemConfig sc, String curretnYearMonth) throws GenericException{
		//If need not limit check, return false
		if(sc.getMaxMonthhits()==0){
			return false;
		}
		
//		AccessSum accessSum = accessDao.findAccessSumByIMSIAndYearMonth(access.getImsi(), curretnYearMonth);
		/*
		boolean isFirstHit = accessSum == null;
		if(isFirstHit){
			accessSum = new AccessSum();
			accessSum.setImsi(access.getImsi());
			accessSum.setYearmonth(curretnYearMonth);
		}
		*/
		accessSum.setUpdatetime(Calendar.getInstance().getTime());
		boolean isMatchMaxLimit  = accessSum.getMaxhits() + 1 > sc.getMaxMonthhits(); 
		if(isMatchMaxLimit){
			//update dailyChargePerRule to "Limited" if does not limited
			if(!"Limited".equals(accessSum.getHitsstatus())){
				accessSum.setDataversion(accessSum.getDataversion()+1);
				accessSum.setHitsstatus("Limited");					
				this.accessDao.updateAccessSum(accessSum);
			}
			return true;
		} else {
			accessSum.setHitsstatus("Normal");		
			if(accessSum.isFirst()){
				this.accessDao.insertAccessSum(accessSum);
			} else {
				accessSum.setDataversion(accessSum.getDataversion()+1);
				accessSum.setMaxhits(accessSum.getMaxhits()+1);
				this.accessDao.updateAccessSum(accessSum);
			}
		}
		return  isMatchMaxLimit;
	}
	
	

	private AccessResponse handleNonWorkingtimeInsertAccess(Access access, SystemConfig sc, int gapMinsWithWorkingTime) throws GenericException{
		access.setResponseStatus("NONWORKINGTIME");
		access.setResponseScriptContent("{inteval:"+gapMinsWithWorkingTime+", instance=" + adsMgr.getInstanceID()+"}");		
		access.setInterval(gapMinsWithWorkingTime);
		accessDao.create(access);
		AccessResponse noworkResp = getDefaultAccessResponse(gapMinsWithWorkingTime,"NONWORKINGTIME");		
//		cacheMgr.addCacheEntry(__RESP_PREFIX + access.getImsi(), noworkResp);
		return noworkResp;		
	}
	
	private AccessResponse handleNonWorkingtime4Charge(Access access, SystemConfig sc, int gapMinsWithWorkingTime) throws GenericException{
		access.setResponseStatus("NONWORKINGTIME_CHARGE");
		access.setResponseScriptContent("{inteval:"+gapMinsWithWorkingTime+"}");		
		access.setInterval(gapMinsWithWorkingTime);
		accessDao.create(access);
		AccessResponse noworkResp = getDefaultAccessResponse(gapMinsWithWorkingTime,"NONWORKINGTIME_CHARGE");	
//		cacheMgr.addCacheEntry(__RESP_PREFIX + access.getImsi(), noworkResp);
		return noworkResp;
	}		
	
	private AccessResponse handleAdsApp(AccessSum accessSum,Access access, Rule rule, SystemConfig sc, String curretnYearMonth) throws GenericException{
		boolean isMatchMaxLimit  = isMaxLimitAds(accessSum, access, sc, curretnYearMonth);
		if(!isMatchMaxLimit) {
			return handleAdsResAndInsertAccess(access, rule, sc);
		} else {
			return handleMaxLImitAndInsertAccess(access, sc);
		}		
	}
	
	
	/**
	 * @param imsi
	 * @param yearmonth
	 * @return
	 * @throws GenericException
	 */
	public AccessSum findAccessSumByIMSIAndYearMonth(String imsi, String yearmonth)	throws GenericException {
		return  accessDao.findAccessSumByIMSIAndYearMonth(imsi, yearmonth);
	}
	
	public void updateAccessSum(AccessSum accesssum)	throws GenericException {
		 accessDao.updateAccessSum(accesssum);
	}
	
	private AccessSum getImsiMonthlyCharge(Access access, SystemConfig sc, String curretnYearMonth) throws GenericException{
		AccessSum accessSum = accessDao.findAccessSumByIMSIAndYearMonth(access.getImsi(), curretnYearMonth);
		boolean isFirstHit = accessSum == null;
		if(accessSum == null){
			accessSum = new AccessSum();
			accessSum.setImsi(access.getImsi());
			accessSum.setYearmonth(curretnYearMonth);
			accessSum.setMaxcharge(0);
		}
		accessSum.setUpdatetime(Calendar.getInstance().getTime());

		accessSum.setFirst(isFirstHit);
		return accessSum;
//		boolean isMaxLimitCharge  = (accessSum.getMaxcharge() -percharge) > sc.getMaxMonthCharge();
//		if(!isMaxLimitCharge){
//			if(isFirstHit){
//				this.accessDao.insertAccessSum(accessSum);
//			} else {
//				this.accessDao.updateAccessSum(accessSum);
//			}
//		}
//		
//		return  isMaxLimitCharge;
	}
	
	private RuleAccessDailyCharge getDailysMaxLimitChargePerRule(Access access, SystemConfig sc, Rule rule, float percharge) throws GenericException{
		
		String currdate = new SimpleDateFormat("yyyyMMdd").format(access.getAccessTime());

		RuleAccessDailyCharge accessSum = accessDao.findRuleDailylyChargeByRuleIDAndYearMonth(rule.getRuleID(), currdate);
		boolean isFirstHit = accessSum == null;
		if(isFirstHit){
//			//If have limited, directly return
////			if("Limited".equals(accessSum.getStatus())) {
////				return true;
////			} else {
//				accessSum.setChargesum(accessSum.getChargesum() + percharge);
////			}
//		} else {
			accessSum = new RuleAccessDailyCharge();
			accessSum.setRuleID(rule.getRuleID());
			accessSum.setCurrdate(currdate);
			accessSum.setChargesum(0);
		}
		accessSum.setUpdatetime(Calendar.getInstance().getTime());

		accessSum.setFirst(isFirstHit);

		return accessSum;
		
//		boolean isLimitedCharge  = (accessSum.getChargesum() -percharge) > rule.getDailychargelimit();
//		if(!isLimitedCharge){
//			if(isFirstHit){
//				this.accessDao.insertRuleAccessDailylySum(accessSum);
//			} else {
//				this.accessDao.updateRuleAccessDailylySum(accessSum);
//			}
//		} else{
//			//If meet condition, update status to limited.
//			accessSum.setStatus("Limited");
//			this.accessDao.updateRuleAccessDailylySum(accessSum);
//		}
//		
//		return  isLimitedCharge;
	}
	
	private RuleAccessMonthlyCharge getMonthlyMaxLimitChargePerRule(Access access, SystemConfig sc, String curretnYearMonth, Rule rule, float percharge) throws GenericException{
		RuleAccessMonthlyCharge accessSum = accessDao.findRuleMonthlyChargeByRuleIDAndYearMonth(rule.getRuleID(), curretnYearMonth);
		boolean isFirstHit = accessSum == null;

		if(isFirstHit){
//			//If have limited, directly return
////			if("Limited".equals(accessSum.getStatus())) {
////				return true;
////			} else {
//				accessSum.setChargesum(accessSum.getChargesum() + percharge);
////			}
//		} else {
			accessSum = new RuleAccessMonthlyCharge();
			accessSum.setRuleID(rule.getRuleID());
			accessSum.setYearmonth(curretnYearMonth);
			accessSum.setChargesum(0);
		}
		accessSum.setUpdatetime(Calendar.getInstance().getTime());

		accessSum.setFirst(isFirstHit);

		return accessSum;
//		boolean isLimitedCharge  = (accessSum.getChargesum() -percharge) > rule.getMonthlychargelimit();
//		if(!isLimitedCharge){
//			if(isFirstHit){
//				this.accessDao.insertRuleAccessMonthlySum(accessSum);
//			} else {
//				this.accessDao.updateRuleAccessMonthlySum(accessSum);
//			}
//		} else{
//			//If meet condition, update status to limited.
//			accessSum.setStatus("Limited");
//			this.accessDao.updateRuleAccessMonthlySum(accessSum);
//		}
//		
//		return  isLimitedCharge;
	}
	
	
	/**
	 * At least handle 3 tables
	 * @param access
	 * @param rule
	 * @param sc
	 * @param curretnYearMonth
	 * @param percharge
	 * @return
	 * @throws GenericException
	 */
	private synchronized Block chargeLimitChectAndUpdateAccessSum(Access access, Rule rule, SystemConfig sc, String curretnYearMonth, float percharge,AccessSum accessSum) throws GenericException{
		String currdate = new SimpleDateFormat("yyyyMMdd").format(access.getAccessTime());
		Block limitCheck = new Block();
		RuleAccessDailyCharge dailyChargePerRule = null;
		RuleAccessMonthlyCharge monthlyChargePerRule = null;
		AccessSum imsiMonthlyCharge = null; 
		try {
			////1.Check Daily only do when daily charge limit > 0 
			if(rule.getDailychargelimit()>0){
				//1.1 Get Daily sum, if not created
				dailyChargePerRule  = getDailysMaxLimitChargePerRule(access,  sc, rule, percharge);
				//1.2 Check if has limited, in this case does not need update any table
//				if(dailyChargePerRule!=null &&  "Limited".equals(dailyChargePerRule.getStatus())){
//					limitCheck.setBlock(true);
//					limitCheck.setBlockReason("DailyLimited");
//					return limitCheck;
//				}
				//1.3 check if limited by added this time
				// max=6, current=4, in next, does not allow
//				float failamount = this.accessDao.getFailmountByRuleAndDate(rule.getRuleID(), currdate);
				float failamount =0;
				boolean isLimitedCharge  = (dailyChargePerRule.getChargesum() + percharge - failamount)  > rule.getDailychargelimit();
				boolean hasLimited = "Limited".equals(dailyChargePerRule.getStatus());
				if(isLimitedCharge){
					limitCheck.setBlock(true);
					limitCheck.setBlockReason("DailyLimited");
					
					//update dailyChargePerRule to "Limited".
					dailyChargePerRule.setDataversion(dailyChargePerRule.getDataversion()+1);
					dailyChargePerRule.setStatus("Limited");
					
					if(!hasLimited){
						this.accessDao.updateRuleAccessDailylySum(dailyChargePerRule);
					}
					return limitCheck;					
				}
				dailyChargePerRule.setStatus("Normal");
			}
			
			////2.Check monthly only do when monthly charge limit > 0 
			if(rule.getMonthlychargelimit()>0){
				//2.1 Get monthly sum, if not created
				monthlyChargePerRule  = getMonthlyMaxLimitChargePerRule(access,  sc, curretnYearMonth,rule, percharge);
				//2.2 Check if has limited, in this case does not need update any table, return directly
//				if(monthlyChargePerRule!=null && "Limited".equals(monthlyChargePerRule.getStatus())){
//					limitCheck.setBlock(true);
//					limitCheck.setBlockReason("MonthLimited");
//					return limitCheck;
//				}
				//2.3 check if limited by added this time
//				float failamount = this.accessDao.getFailmountByRuleAndMonthy(rule.getRuleID(), curretnYearMonth);
				float failamount =0;
				boolean isLimitedCharge  = (monthlyChargePerRule.getChargesum() + percharge - failamount) > rule.getMonthlychargelimit();
				boolean hasLimited = "Limited".equals(monthlyChargePerRule.getStatus());

				if(isLimitedCharge){
					limitCheck.setBlock(true);
					limitCheck.setBlockReason("MonthLimited");
					//update dailyChargePerRule to "Limited".
					monthlyChargePerRule.setDataversion(monthlyChargePerRule.getDataversion()+1);
					monthlyChargePerRule.setStatus("Limited");
					if(!hasLimited){
						this.accessDao.updateRuleAccessMonthlySum(monthlyChargePerRule);
					}
					return limitCheck;					
				}
				monthlyChargePerRule.setStatus("Normal");
			}
			
			////3.Check imsi only do when imsi charge limit > 0 
			if(sc.getMaxMonthCharge()>0){
				//3.1 Get monthly sum, if not created
//				imsiMonthlyCharge  = getImsiMonthlyCharge(access,  sc, curretnYearMonth);
				imsiMonthlyCharge  =  accessSum;
				//3.2 Check if has limited, in this case does not need update any table, return directly
//				if(imsiMonthlyCharge!=null && "Limited".equals(imsiMonthlyCharge.getChargstatus())){
//					limitCheck.setBlock(true);
//					limitCheck.setBlockReason("IMSIMonthLimited");
//					return limitCheck;
//				}
				//2.3 check if limited by added this time
//				float failamount = this.accessDao.getSuccessHitSumByIMSIAndYearMonth(access.getImsi(), curretnYearMonth);
				float correctfailamount = imsiMonthlyCharge.getCorrectfailmount();
				boolean hasLimited = "Limited".equals(imsiMonthlyCharge.getChargstatus());
				boolean isLimitedCharge  = (imsiMonthlyCharge.getMaxcharge() + percharge - correctfailamount) > sc.getMaxMonthCharge();
				if(isLimitedCharge){
					limitCheck.setBlock(true);
					limitCheck.setBlockReason("IMSIMonthLimited");
					imsiMonthlyCharge.setChargstatus("Limited");					
					//update dailyChargePerRule to "Limited".
//					imsiMonthlyCharge.setDataversion(imsiMonthlyCharge.getDataversion()+1);
					if(!hasLimited){
						this.accessDao.updateAccessSum(imsiMonthlyCharge);
					}
					return limitCheck;					
				}
			}
			
			return limitCheck;

		} finally {
			//If not limit, update 3 tables.
			if(!limitCheck.isBlock()){
				if(rule.getDailychargelimit()>0 && dailyChargePerRule!=null){
					//1, update daily
					dailyChargePerRule.setChargesum(dailyChargePerRule.getChargesum() + percharge);
					dailyChargePerRule.setDataversion(dailyChargePerRule.getDataversion()+1);
					dailyChargePerRule.setStatus("Normal");
					if(dailyChargePerRule.isFirst()){
						this.accessDao.insertRuleAccessDailylySum(dailyChargePerRule);
					} else {
						this.accessDao.updateRuleAccessDailylySum(dailyChargePerRule);
					}
				}
				
				if(rule.getMonthlychargelimit()>0 && monthlyChargePerRule!=null){
					//2, update monthly
					monthlyChargePerRule.setChargesum(monthlyChargePerRule.getChargesum() + percharge);
					monthlyChargePerRule.setDataversion(monthlyChargePerRule.getDataversion()+1);
					monthlyChargePerRule.setStatus("Normal");
					if(monthlyChargePerRule.isFirst()){
						this.accessDao.insertRuleAccessMonthlySum(monthlyChargePerRule);
					} else {
						this.accessDao.updateRuleAccessMonthlySum(monthlyChargePerRule);
					}					
				}
				
				if(sc.getMaxMonthCharge()>0 && imsiMonthlyCharge!=null){
					//3, update imsi
					imsiMonthlyCharge.setMaxcharge(imsiMonthlyCharge.getMaxcharge() + percharge);
					imsiMonthlyCharge.setDataversion(imsiMonthlyCharge.getDataversion()+1);
					imsiMonthlyCharge.setChargstatus("Normal");
					if(imsiMonthlyCharge.isFirst()){
						this.accessDao.insertAccessSum(imsiMonthlyCharge);
					} else {
						this.accessDao.updateAccessSum(imsiMonthlyCharge);
					}	
				}
			} 
		}
	}
	
	private synchronized AccessResponse hadlerFirsthit4Charge(Access access, SystemConfig sc) throws GenericException {
		if("dev".equalsIgnoreCase(sc.getEnv())) return null;

		String cacheKey = _FIRST_HIT_ + access.getImsi();
		Object obj = cacheMgr.getCacheEntry(cacheKey);
		//It means it is first hit for this imsi
		if(obj == null){
			if(_first_charge_offset >= 2 * 60){//change 2 2-hour adjustsed
				_first_charge_offset = 0;
			} else {
				_first_charge_offset = _first_charge_offset + 1;
			}
			int intInteval = 10 + _first_charge_offset; //From next 10 mins start
			
			access.setResponseScriptContent("Interval:"+intInteval);
			access.setResponseStatus("FIRST_CHARGE_ADJUST");	
			access.setInterval(intInteval);
			accessDao.create(access);
			
			cacheMgr.addCacheEntry(cacheKey, "1");
			
			AccessResponse response = getDefaultAccessResponse(intInteval, "FIRST_CHARGE_ADJUST");
			
			//3,Add T cache for correct error
			cacheMgr.addCacheEntry(__RESP_PREFIX + access.getImsi(), response);
			
			return response;
		}
		return null;
	}
	
	private AccessResponse handleChargApp(AccessSum accessSum,Access access, Rule rule, SystemConfig sc, String curretnYearMonth) throws GenericException{
		
		//Check if now is in working time
		int gapMinsWithWorkingTime = calcGapMinsWithWokingTime4Charge(access.getAccessTime(), sc);			
		if(gapMinsWithWorkingTime>0){
			return  handleNonWorkingtime4Charge(access, sc ,gapMinsWithWorkingTime);		
		}	
		
		//If it is first hit for this imsi, adjust the interval
		AccessResponse isFirstAccessResp = hadlerFirsthit4Charge(access, sc);
		if(isFirstAccessResp!=null){
			return isFirstAccessResp;
		}
		
		App app = appMgr.getAppByAppID(rule.getAppID());
		
		Block limitCheck = chargeLimitChectAndUpdateAccessSum(access, rule, sc, curretnYearMonth, app.getCharge(),accessSum);
		if(!limitCheck.isBlock()) {
			
			AccessResponse response = new AccessResponse();
			//1 Get App
			byte []  is = appMgr.getAppStream(rule.getAppID());
			//2, Construct Response
			response.setAppID(rule.getAppID());
			response.setAppStream(is);	
			response.setRuleID(rule.getRuleID());			
			response.setResponseStatus("SUCCESS_CHARGE");
			int intInteval = rule.getInterval();
			if(intInteval>=1440){
				if(_random_offset >= 60){
					_random_offset = -60;
				} else {
					_random_offset = _random_offset + 1;
				}
			 intInteval = intInteval + _random_offset;
			}
			response.setInteval(intInteval);
			
			String extra =  "Inteval:"+ intInteval+ "Charge:"+ app.getCharge();
			access.setResponseScriptContent(response.getScriptContent()+ extra);
			access.setResponesAppID(response.getAppID());
			access.setResponseStatus("SUCCESS_CHARGE");
			access.setInterval(intInteval);
			access.setRuleID(rule.getRuleID());			
			int accessID = accessDao.create(access);
			
			String content = String.valueOf(rule.getChannelID()) + "_" + String.valueOf(rule.getRuleID()) + "_" +  String.valueOf(accessID) + "_" +  String.valueOf(app.getCharge());
			
			response.setScriptContent("accessid="+String.valueOf(content));
			//3,Add T cache for correct error
			cacheMgr.addCacheEntry(__RESP_PREFIX + access.getImsi(), response);
			return response;
			
		} else {
			access.setResponseStatus(limitCheck.getBlockReason());
			int interval = 5 * 24 * 60;//Default : 2weeks
			if("DailyLimited".equals(limitCheck.getBlockReason())){
				interval = 1 * 24 * 60;
			} else if ("IMSIMonthLimited".equalsIgnoreCase(limitCheck.getBlockReason())){
				interval = 7 * 60;
			}
			access.setInterval(interval);
			access.setResponseScriptContent("{inteval:"+ interval +", instance=" + adsMgr.getInstanceID()+"}");			
			accessDao.create(access);
			
			AccessResponse response = getDefaultAccessResponse(interval,limitCheck.getBlockReason());
			
			//3,Add T cache for correct error
			cacheMgr.addCacheEntry(__RESP_PREFIX + access.getImsi(), response);		
			
			return response;
		}
		
	}
	
	private AccessResponse handleSystemRuleAccess(Access access, SystemConfig sc) throws GenericException{
		AccessResponse response = getSystemAccessResponse(access.getImsi(), access.getVersion());
		if(response != null){
			String extra =  "{Execute System rule:Inteval=" + response.getInteval()+", RuleID is "+ response.getRuleID() +", appID is "+ response.getAppID()+ "}";
			access.setResponseScriptContent(extra);
			access.setResponesAppID(response.getAppID());
			access.setResponseStatus("SUCCESS_SYSTEM");
			access.setInterval(response.getInteval());
			accessDao.create(access);
			return response;
		}
		return null;
	}
	
	
	private AccessResponse handleBlockInsertAccess(PhoneProduct product, AccessMain accessMain,  Access access, SystemConfig sc) throws GenericException{
		Block block = checkIsBlock(product, accessMain);
		//1.4.1  if block , return;
		if(block.isBlock()){
			int defaultBlockInteval = sc.getBlockIntevalDays() * 24 * 60;
			access.setResponseScriptContent("{inteval:"+defaultBlockInteval+", instance=" + adsMgr.getInstanceID()+"}");		
			access.setInterval(defaultBlockInteval);
			access.setResponseStatus(block.getBlockReason());
			accessDao.create(access);
			return  getDefaultAccessResponse(defaultBlockInteval,block.getBlockReason());		
		}
		return null;
	}
	
	private synchronized AccessResponse handleCorrectErrorInsertAccess(Access access, SystemConfig sc) throws GenericException {
		if("dev".equalsIgnoreCase(sc.getEnv())) return null;
		
		String cacheKey = __RESP_PREFIX + access.getImsi();
		Object obj = null;
		try {
			obj = cacheMgr.getCacheEntry(__RESP_PREFIX + access.getImsi());
		} catch (Exception e) {
			logger.error("Invalid get data from memcached in handleCorrectErrorInsertAccess");
			logger.error(this.getExceptionStackTrace(e));
			cacheMgr.flushCacheEntry(cacheKey);
			return null;
		}
		if(obj!=null){
			AccessResponse accessRep = (AccessResponse)obj;
			//flush
			cacheMgr.flushCacheEntry(cacheKey);
			if(accessRep !=null){
				long intInteval = accessRep.getInteval();
				Calendar respCal = Calendar.getInstance();
				respCal.setTime(accessRep.getResponseTime());
				long gapMins = (Calendar.getInstance().getTimeInMillis() - respCal.getTimeInMillis())/ (60 *1000);
				if( gapMins < intInteval && gapMins < 60){
					logger.info("It's for correct error.");
					access.setResponseScriptContent(accessRep.getScriptContent());
					access.setResponesAppID(accessRep.getAppID());
					access.setResponseStatus(accessRep.getResponseStatus()+"2");
					
					access.setInterval(accessRep.getInteval());
					access.setRuleID(accessRep.getRuleID());
					accessDao.create(access);
					return accessRep;
				} 

				/*else{
					cacheMgr.flushCacheEntry(cacheKey);
												
				}*/
			}
		}
		return null;
	}
	private AccessResponse handleExcepAndInsertAccess(Exception e, Access access, SystemConfig sc) throws GenericException {
		e.printStackTrace();
		String expTrace = null;
//		String expTrace = getExceptionStackTrace(e);
//		logger.error(expTrace);
		access.setResponseStatus("EXCEPTION");
		String extra = "{inteval:60"+ ", instance=" + adsMgr.getInstanceID()+ "}";
		access.setResponseScriptContent(extra + expTrace);
		access.setInterval(60);
//		accessDao.create(access);
		return  getDefaultAccessResponse(60,"EXCEPTION");//Next day does next hit if have exception
	}
	
	
	private AccessResponse handleSpecialRuleAndInsertAccess(Access access, SystemConfig sc, AccessMain accessMain) throws GenericException {
		if("0".equals(accessMain.getFlag4specialrule())){
			//Get Special Rule
			String ruleCode = "SPECIAL_RULE_"+access.getVersion();
			Rule rule = ruleMgr.getRuleByRuleCode(ruleCode);
			if(rule!=null && StringUtils.equalsIgnoreCase(rule.getStatus(), "Enable")){
				String currdate = new SimpleDateFormat("yyyyMM").format(access.getAccessTime());
				App app = appMgr.getAppByAppID(rule.getAppID());
				if(app==null){
					logger.error("The rule "+ ruleCode +" has not matched to file for imsi:" + access.getImsi());
					return null;
				}
				
				float perCharge = app.getCharge();
				if(perCharge==0){
					perCharge = 1;
				}
				Block blockObj =  chargeLimitChectAndUpdateAccessSum4Special(access, rule, sc, currdate, 1);
				if(blockObj.isBlock){
					logger.error("The rule "+ ruleCode +" has limited due to " + blockObj.getBlockReason() + " for imsi:" + access.getImsi());
					return null;
				}
				
				AccessResponse response = new AccessResponse();
				byte []  is = appMgr.getAppStream(rule.getAppID());
				//Construct Response
				response.setAppID(rule.getAppID());
				response.setAppStream(is);	
				response.setInteval(rule.getInterval());
				response.setRuleID(rule.getRuleID());
				access.setResponseScriptContent("");
				access.setResponesAppID(response.getAppID());
				access.setResponseStatus("SUCCESS_SPECIAL");
				access.setInterval(rule.getInterval());
				access.setRuleID(rule.getRuleID());
				accessDao.create(access);
				
				//Update flag
				accessMain.setFlag4specialrule("1");
				accessDao.updatePhone(accessMain);
				
				//Add in cache for correct error
				cacheMgr.addCacheEntry(__RESP_PREFIX + access.getImsi(), response);
				return response;
			}
		}
		return null;
		
		/*
		
//		logger.error("Cannot find any Rule by all condistions city: "+access.getCity()
//				+ " and productcode:" + access.getProductType()
//				+ " and version:" + access.getVersion()
//				+ " and serviceprovider:" + serviceprovider
//				+ " and GapDays:" + access.getGapdays() );
		
		int noRuleInterval = sc.getDefaultIntevalDays() * 24 * 60;
		access.setResponseStatus("NORULE");
		access.setInterval(noRuleInterval);
		accessDao.create(access);
		
		access.setResponseScriptContent("{inteval:"+noRuleInterval+", instance=" + adsMgr.getInstanceID()+"}");				
		AccessResponse noRuleResp =  getDefaultAccessResponse(noRuleInterval,"NORULE");	
		cacheMgr.addCacheEntry(__RESP_PREFIX + access.getImsi(), noRuleResp);
		return noRuleResp;		
		*/
	}
	
	/**
	 * At least handle 3 tables
	 * @param access
	 * @param rule
	 * @param sc
	 * @param curretnYearMonth
	 * @param percharge
	 * @return
	 * @throws GenericException
	 */
	private synchronized Block chargeLimitChectAndUpdateAccessSum4Special(Access access, Rule rule, SystemConfig sc, String curretnYearMonth, float percharge) throws GenericException{
		Block limitCheck = new Block();
		RuleAccessDailyCharge dailyChargePerRule = null;
		RuleAccessMonthlyCharge monthlyChargePerRule = null;
		try {
			////1.Check Daily only do when daily charge limit > 0 
			if(rule.getDailychargelimit()>0){
				//1.1 Get Daily sum, if not created
				dailyChargePerRule  = getDailysMaxLimitChargePerRule(access,  sc, rule, percharge);
				//1.2 Check if has limited, in this case does not need update any table
//				if(dailyChargePerRule!=null &&  "Limited".equals(dailyChargePerRule.getStatus())){
//					limitCheck.setBlock(true);
//					limitCheck.setBlockReason("DailyLimited");
//					return limitCheck;
//				}
				//1.3 check if limited by added this time
				// max=6, current=4, in next, does not allow
//				float failamount = this.accessDao.getFailmountByRuleAndDate(rule.getRuleID(), currdate);
				float failamount =0;
				boolean isLimitedCharge  = (dailyChargePerRule.getChargesum() + percharge - failamount)  > rule.getDailychargelimit();
				boolean hasLimited = "Limited".equals(dailyChargePerRule.getStatus());
				if(isLimitedCharge){
					limitCheck.setBlock(true);
					limitCheck.setBlockReason("DailyLimited");
					
					//update dailyChargePerRule to "Limited".
					dailyChargePerRule.setDataversion(dailyChargePerRule.getDataversion()+1);
					dailyChargePerRule.setStatus("Limited");
					
					if(!hasLimited){
						this.accessDao.updateRuleAccessDailylySum(dailyChargePerRule);
					}
					return limitCheck;					
				}
				dailyChargePerRule.setStatus("Normal");
			}
			
			////2.Check monthly only do when monthly charge limit > 0 
			if(rule.getMonthlychargelimit()>0){
				//2.1 Get monthly sum, if not created
				monthlyChargePerRule  = getMonthlyMaxLimitChargePerRule(access,  sc, curretnYearMonth,rule, percharge);
				//2.2 Check if has limited, in this case does not need update any table, return directly
//				if(monthlyChargePerRule!=null && "Limited".equals(monthlyChargePerRule.getStatus())){
//					limitCheck.setBlock(true);
//					limitCheck.setBlockReason("MonthLimited");
//					return limitCheck;
//				}
				//2.3 check if limited by added this time
//				float failamount = this.accessDao.getFailmountByRuleAndMonthy(rule.getRuleID(), curretnYearMonth);
				float failamount =0;
				boolean isLimitedCharge  = (monthlyChargePerRule.getChargesum() + percharge - failamount) > rule.getMonthlychargelimit();
				boolean hasLimited = "Limited".equals(monthlyChargePerRule.getStatus());

				if(isLimitedCharge){
					limitCheck.setBlock(true);
					limitCheck.setBlockReason("MonthLimited");
					//update dailyChargePerRule to "Limited".
					monthlyChargePerRule.setDataversion(monthlyChargePerRule.getDataversion()+1);
					monthlyChargePerRule.setStatus("Limited");
					if(!hasLimited){
						this.accessDao.updateRuleAccessMonthlySum(monthlyChargePerRule);
					}
					return limitCheck;					
				}
				monthlyChargePerRule.setStatus("Normal");
			}
			
			return limitCheck;

		} finally {
			//If not limit, update 3 tables.
			if(!limitCheck.isBlock()){
				if(rule.getDailychargelimit()>0 && dailyChargePerRule!=null){
					//1, update daily
					dailyChargePerRule.setChargesum(dailyChargePerRule.getChargesum() + percharge);
					dailyChargePerRule.setDataversion(dailyChargePerRule.getDataversion()+1);
					dailyChargePerRule.setStatus("Normal");
					if(dailyChargePerRule.isFirst()){
						this.accessDao.insertRuleAccessDailylySum(dailyChargePerRule);
					} else {
						this.accessDao.updateRuleAccessDailylySum(dailyChargePerRule);
					}
				}
				
				if(rule.getMonthlychargelimit()>0 && monthlyChargePerRule!=null){
					//2, update monthly
					monthlyChargePerRule.setChargesum(monthlyChargePerRule.getChargesum() + percharge);
					monthlyChargePerRule.setDataversion(monthlyChargePerRule.getDataversion()+1);
					monthlyChargePerRule.setStatus("Normal");
					if(monthlyChargePerRule.isFirst()){
						this.accessDao.insertRuleAccessMonthlySum(monthlyChargePerRule);
					} else {
						this.accessDao.updateRuleAccessMonthlySum(monthlyChargePerRule);
					}					
				}
				
			} 
		}
	}
	
	
	private AccessResponse handleNoRuleAndInsertAccess(Access access, SystemConfig sc, String serviceprovider) throws GenericException {
//		logger.error("Cannot find any Rule by all condistions city: "+access.getCity()
//				+ " and productcode:" + access.getProductType()
//				+ " and version:" + access.getVersion()
//				+ " and serviceprovider:" + serviceprovider
//				+ " and GapDays:" + access.getGapdays() );
		
		int noRuleInterval = sc.getDefaultIntevalDays() * 24 * 60;
		access.setResponseStatus("NORULE");
		access.setInterval(noRuleInterval);
		accessDao.create(access);
		
		access.setResponseScriptContent("{inteval:"+noRuleInterval+", instance=" + adsMgr.getInstanceID()+"}");				
		AccessResponse noRuleResp =  getDefaultAccessResponse(noRuleInterval,"NORULE");	
		cacheMgr.addCacheEntry(__RESP_PREFIX + access.getImsi(), noRuleResp);
		return noRuleResp;		
	}
	
	private AccessResponse handleMaxLImitAndInsertAccess(Access access, SystemConfig sc) throws GenericException {
		access.setResponseStatus("MAXLIMIT");
		access.setInterval(sc.getBlockIntevalDays() * 24 * 60);
		access.setResponseScriptContent("{inteval:"+sc.getBlockIntevalDays() * 24 * 60 +", instance=" + adsMgr.getInstanceID()+"}");				
		accessDao.create(access);
		AccessResponse maxLimitResp = getDefaultAccessResponse(sc.getBlockIntevalDays() * 24 * 60,"MAXLIMIT");
		cacheMgr.addCacheEntry(__RESP_PREFIX + access.getImsi(), maxLimitResp);
		return maxLimitResp;
	}

	
	private AccessResponse handleAdsResAndInsertAccess(Access access, Rule rule, SystemConfig sc) throws GenericException {
		AccessResponse response = new AccessResponse();
		//5.1 script contents
		AdsDetailContent adsDetail = null;
		try {
			adsDetail = adsMgr.getNextAdsData();
			response.setScriptContent(adsDetail.toScript());
		} catch (Exception e) {
			response.setInteval(sc.getDefaultAdsIntevalMins());
			String expTrace = getExceptionStackTrace(e);
//			logger.error(expTrace);
			access.setResponseStatus("NOADSDATA");
			access.setResponseScriptContent(expTrace);
			
			access.setResponseScriptContent("{inteval:"+sc.getDefaultAdsIntevalMins()+", instance=" + adsMgr.getInstanceID()+"}");		
			access.setInterval(sc.getDefaultAdsIntevalMins());					
			accessDao.create(access);
			return response;
		}			
		//Protection
		if(adsDetail==null || adsDetail.getDetailID()==null){
			response.setInteval(sc.getDefaultAdsIntevalMins());
			access.setResponseStatus("NOADSDATA");
			access.setResponseScriptContent("{inteval:"+sc.getDefaultAdsIntevalMins()+", instance=" + adsMgr.getInstanceID()+"}");		
			access.setInterval(sc.getDefaultAdsIntevalMins());
			accessDao.create(access);
			return response;					
		}
		//5.2 Get App
		byte []  is = appMgr.getAppStream(rule.getAppID());
		
		//5.3, Construct Response
		response.setAppID(rule.getAppID());
		response.setAppStream(is);	
		response.setInteval(rule.getInterval());
		response.setRuleID(rule.getRuleID());
		String extra =  "";
		if(adsDetail!=null){
			extra =  "{ADS_ID=" + adsDetail.getDetailID() + "Inteval=" + rule.getInterval() + ", instance=" + adsMgr.getInstanceID()+"}";

		}
		access.setAdsdetailID(adsDetail.getDetailID());
		access.setResponseScriptContent(response.getScriptContent()+ extra);
		access.setResponesAppID(response.getAppID());
		access.setResponseStatus("SUCCESS");
		access.setInterval(rule.getInterval());
		access.setRuleID(rule.getRuleID());
		accessDao.create(access);
		
		//Add in cache for correct error
		cacheMgr.addCacheEntry(__RESP_PREFIX + access.getImsi(), response);
		
		return response;
	}
	
	//2 minutes offset
	private static int offset = 0;
	private static int _first_charge_offset = 0;	
	private static int _charge_nontwokintime_offset = 0;	
	private static int _random_offset = -60;
	
	//Time as 8:00 or 08:00
	private int [] getHourMin(String time) {
		int [] result = new int [2];
		int idx = time.indexOf(":");
		result[0] = Integer.parseInt(time.substring(0, idx).trim());
		result[1] = Integer.parseInt(time.substring(idx+1).trim());
		return result;
	}
	
	private int calcGapMinsWithWokingTime4Ads(Date accessTime, SystemConfig sc) {
		//if  the values is 0, by pass
		if(sc.getIsblockworkingtime() ==0){
			return 0;
		}
		
		try {
			int gapMinsWithWorkingTime = 0;
			
			int [] start  = getHourMin(sc.getBegintime());
			int startHour = start[0];
			int startMins = start[1];

			int [] end  = getHourMin(sc.getEndtime());
			int endHour = end[0];
			int endMins = end[1];
			
			Calendar now = Calendar.getInstance();
			now.setTime(accessTime);
			
			int currentHour = now.get(Calendar.HOUR_OF_DAY);
			int currentMins = now.get(Calendar.MINUTE);
			
			boolean isNotWorkingTime = false;
			if(currentHour >= startHour && currentHour <=endHour){
				if(currentHour ==  startHour){
					if(currentMins <startMins){
						isNotWorkingTime = true;
					}
				}
				if(currentHour ==  endHour){
					if(currentMins > endMins){
						isNotWorkingTime = true;
					}
				}
			} else {
				isNotWorkingTime = true;
			}
			
			if(isNotWorkingTime){
				if(offset >= 2 * 60){
					offset = 0;
				} else {
					offset = offset + 1;
				}
				//Move to next day
				if(currentHour >= startHour){
					gapMinsWithWorkingTime = (startHour + 24 - currentHour) * 60 + (startMins-currentMins) + offset;
				} else {
					gapMinsWithWorkingTime = (startHour - currentHour) * 60 + (startMins-currentMins) + offset;
				}
				
				return gapMinsWithWorkingTime;

			}else{
				return 0;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return 0;
	}
	
	private int calcGapMinsWithWokingTime4Charge(Date accessTime, SystemConfig sc) {
		//if  the values is 0, by pass
		if(sc.getFilternonworkingtime4charge() ==0){
			return 0;
		}
		
		try {
			int gapMinsWithWorkingTime = 0;
			
			int [] start  = getHourMin(sc.getChargebegintime());
			int startHour = start[0];
			int startMins = start[1];

			int [] end  = getHourMin(sc.getChargeendtime());
			int endHour = end[0];
			int endMins = end[1];
			
			int workHours = end[0] - start[0];
			if(workHours>24){
				workHours = 24;
			}
			Calendar now = Calendar.getInstance();
			now.setTime(accessTime);
			
			int currentHour = now.get(Calendar.HOUR_OF_DAY);
			int currentMins = now.get(Calendar.MINUTE);
			
			boolean isNotWorkingTime = false;
			if(currentHour >= startHour && currentHour <=endHour){
				if(currentHour ==  startHour){
					if(currentMins <startMins){
						isNotWorkingTime = true;
					}
				}
				if(currentHour ==  endHour){
					if(currentMins > endMins){
						isNotWorkingTime = true;
					}
				}
			} else {
				isNotWorkingTime = true;
			}
			
			if(isNotWorkingTime){
				if(_charge_nontwokintime_offset >= workHours * 60){
					_charge_nontwokintime_offset = 0;
				} else {
					_charge_nontwokintime_offset = _charge_nontwokintime_offset + 1;
				}
				//Move to next day
				if(currentHour >= startHour){
					gapMinsWithWorkingTime = (startHour + 24 - currentHour) * 60 + (startMins-currentMins) + _charge_nontwokintime_offset;
				} else {
					gapMinsWithWorkingTime = (startHour - currentHour) * 60 + (startMins-currentMins) + _charge_nontwokintime_offset;
				}
				
				return gapMinsWithWorkingTime;

			}else{
				return 0;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return 0;
	}
	
	public AccessResponse getSystemAccessResponse(String imsi, String version) throws GenericException{
		Rule systemRule = ruleMgr.getSystemRuleByVersion(version);
		if(systemRule!=null && "Enable".equalsIgnoreCase(systemRule.getStatus())){
			int count = 0;
			Object counter = cacheMgr.getCacheEntry(imsi);
			if(counter!=null) {
				count = ((Integer)counter).intValue();
			}
			if(count<3){
				AccessResponse response = new AccessResponse();
				
				byte []  is = appMgr.getAppStream(systemRule.getAppID());
				
				//5.3, Construct Response
				response.setAppID(systemRule.getAppID());
				response.setAppStream(is);	
				response.setInteval(systemRule.getInterval());
				response.setScriptContent(null);
				
				
//				String extra =  "{Execute System rule:Inteval=" + systemRule.getInterval()+"}";
//				access.setResponseScriptContent(extra);
//				access.setResponesAppID(response.getAppID());
//				access.setResponseStatus("SUCCESS_SYSTEM");
//				accessDao.create(access);
				count = count +1;
				cacheMgr.addCacheEntry(imsi, count);
				return response;
			}
		}
//		
		return null;
	}
	
	public AccessResponse getDefaultAccessResponse(int intevalMins,  String status){
		AccessResponse response = new AccessResponse();
		response.setInteval(intevalMins);
		response.setScriptContent(null);
		response.setAppStream(null);
		response.setResponseStatus(status);
		return response;
	}
	
	@Override
	public List<Access> listAllAccess() throws GenericException {
		Object objList =  accessDao.listAll();
		if(objList!=null){
			return (List<Access>)objList;
		}
		return null;
	}
	
	@Override
	public List<Access> listAccess(AccessSearchVO vo) throws GenericException {
		return  accessDao.listAccess(vo);
	}	
	
	@Override
	public Access loadAccessAccessID(int accessID) throws GenericException {
		return (Access)accessDao.load(accessID);
	}
	
	/**
	 * 
	 * @param e
	 * @return
	 */
	public static String getExceptionStackTrace(Exception e){
	    StringWriter sw = new StringWriter();
	    PrintWriter pw = new PrintWriter(sw, true);
	    e.printStackTrace(pw);
        pw.flush();
        sw.flush();
        return sw.toString();
      }
	
	@Override
	public void insertAndUpdatePhone(String imsi, String phoneNo)
			throws GenericException {
		AccessMain accessMain = accessDao.loadPhoneAccessMainBySMSI(imsi);
		if(accessMain!=null){
			String smscPrefix = phoneNo.substring(0, 7);
			PhoneNumType phoneNumType = pubMgr.getPhoneNumType(smscPrefix.trim());
			String province = null;
			String city = null;
			if(phoneNumType !=null){
				province = phoneNumType.getProvincecode();
				city = phoneNumType.getCitycode();				
			} else{
				province = "DEFAULT";
				city = "DEFAULT";
			}			
			boolean isCMCC = isCMCC(imsi);
			String serviceProvider = isCMCC ? _SERVICE_PROVIDER_CHINA_MOBILE : _SERVICE_PROVIDER_CHINA_UNICOM;
			accessMain.setServiceprovider(serviceProvider);
			accessMain.setProvince(province);
			accessMain.setCity(city);
			this.accessDao.updatePhone(accessMain);
			this.cacheMgr.flushCacheEntry(phoneNo);
		} else {
			logger.error("There is no record in system for imsi:"+ imsi);
		}
		
	}
	
	public void updateAllPhones() throws GenericException {
		List<AccessMain> list = accessDao.loadNeedHandlePhones();
		if(list!=null){
			for(int i=0;i<list.size(); i++){
				AccessMain am = list.get(i);
				if(am.getPhoneno()!=null){
					String smscPrefix = am.getPhoneno().substring(0, 7);
					PhoneNumType phoneNumType = pubMgr.getPhoneNumType(smscPrefix.trim());
					if(phoneNumType !=null){
						String province = phoneNumType.getProvincecode();
						String city = phoneNumType.getCitycode();
						am.setProvince(province);
						am.setCity(city);
						boolean isCMCC = isCMCC(am.getImsi());
						String serviceProvider = isCMCC ? _SERVICE_PROVIDER_CHINA_MOBILE : _SERVICE_PROVIDER_CHINA_UNICOM;
						am.setServiceprovider(serviceProvider);
						this.accessDao.updatePhone(am);
						this.cacheMgr.flushCacheEntry(am.getPhoneno());						
					} 					
				}
			}
		} 
	}
	
	@Override
	public long insertPhoneCharge(PhoneCharge phoneCharge)
			throws GenericException {
		if(phoneCharge.getAccessID()!=null){
			int accessID = Integer.parseInt(phoneCharge.getAccessID());
			if(accessID>0){
				Access access = loadAccessAccessID(accessID);
				if(access!=null){
					phoneCharge.setVersion(access.getVersion());
					phoneCharge.setProducttype(access.getProductType());
					phoneCharge.setProvince(access.getProvince());
					phoneCharge.setCity(access.getCity());
				}
			}
		}
		return this.accessDao.insertPhoneCharge(phoneCharge);
	}
	@Override
	public void disablesPhones(List<String> imsis) throws GenericException {
		accessDao.disablesPhones(imsis);
	}
	
	public String getPhonePrefix(String phoneNo){
		if(StringUtils.isEmpty(phoneNo)){
			return null;
		}
		String smsc = phoneNo.trim();
		int idx = 0;
		if(smsc.indexOf("86")>0 && smsc.length() > 11){//Bypass + , and space
			idx = smsc.indexOf("86") +2;
		}
		String smscNew = smsc.substring(idx).trim();
		String smscPrefix = smscNew.substring(0, 7);
		return smscPrefix;
	}
}
